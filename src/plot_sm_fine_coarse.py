#!/usr/bin/env python3
"""
Soil Moisture: Fine vs Coarse Comparison
========================================

This script compares fine-resolution soil moisture estimates (SM_fine,
approximately 3 km native grid) with coarse-resolution soil moisture
measurements (SM_coarse, aggregated to approximately 36 km) across a
set of dates. The goal is to assess consistency, bias, and spatial
correlation between high-resolution retrievals and coarser reference
products (e.g., SMAP or aggregated fine data).

What this script does:
- Loads per-date fine-resolution SM files (prefers a "relaxed" variant when
  available).
- Attempts to load a pre-extracted coarse SM file (NPZ). If not available
  or incompatible, falls back to aggregating the fine data into coarse
  blocks using block averaging.
- Computes summary statistics (mean, std, min, max) for both fields.
- Creates a 3-panel figure: native fine grid, aggregated coarse grid, and
  a scatter plot comparing aggregated fine vs coarse values with correlation
  and error metrics (RMSE, bias).

Notes for readers:
- The script contains robust fallbacks for mismatched grid shapes and
  missing coordinate arrays; these choices are documented inline.
- All outputs (PNG plots) are saved to the processed data `plots/` folder.
"""

import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

# --------------------------
# Configuration
# --------------------------
# Dates to analyze (YYYYMMDD)
DATES = ['20150607', '20150610', '20150615', '20150618', '20150620']

# Base directory with processed NPZ files generated by upstream steps
DATA_DIR = Path(r"c:\Users\ortuo\tfgirati\tfg-nisar\data\processed")

# Output folder for generated plots (created if it does not exist)
OUTPUT_DIR = DATA_DIR / "plots"
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

# Spatial cropping window used to remove potential edge artifacts from the
# native fine grid. These numbers are in native pixel coordinates.
CROP_Y = 27  # number of rows to keep
CROP_X = 35  # number of columns to keep

# Geographic bounding box for the study region (WGS84 lon/lat). Used only
# for plotting extents (best-effort labeling) when the coarse/fine grids are
# in the same projected space.
LON_MIN = -104.8884912
LAT_MIN = 39.8008444
LON_MAX = -103.7115088
LAT_MAX = 40.6991556

def aggregate_to_coarse(fine_data, native_shape=(30, 39), coarse_shape=(3, 5)):
    """
    Downscale a fine-resolution array to a coarse grid by block averaging.

    The function divides the fine grid into `coarse_shape` blocks and computes
    the mean of each block, skipping NaNs (np.nanmean). It attempts to handle
    cases where the native shape is not evenly divisible by the coarse shape
    by using integer division for block size and slicing accordingly; any
    leftover rows/columns at the right/bottom edges are ignored.

    Args:
        fine_data: 2D NumPy array containing fine-resolution values
        native_shape: the expected shape of the full native grid (rows, cols)
        coarse_shape: desired coarse grid shape (rows, cols)

    Returns:
        coarse: 2D NumPy array with shape `coarse_shape` containing block means
    """
    # Calculate block sizes (integer division). This intentionally ignores a
    # small remainder if native_shape is not divisible by coarse_shape.
    block_y = native_shape[0] // coarse_shape[0]
    block_x = native_shape[1] // coarse_shape[1]

    # Initialize coarse array with NaNs to detect empty blocks later
    coarse = np.full(coarse_shape, np.nan, dtype=float)

    # Aggregate by blocks (mean of each block). Use np.nanmean so that missing
    # values do not bias the mean; if an entire block is NaN, result will be NaN.
    for i in range(coarse_shape[0]):
        for j in range(coarse_shape[1]):
            y_start = i * block_y
            y_end = (i + 1) * block_y
            x_start = j * block_x
            x_end = (j + 1) * block_x

            block = fine_data[y_start:y_end, x_start:x_end]
            try:
                coarse[i, j] = np.nanmean(block)
            except Exception:
                # If the block is empty or cannot be averaged, leave as NaN
                coarse[i, j] = np.nan

    return coarse

print("="*70)
print("SM FINE vs COARSE COMPARISON - ALL DATES")
print("="*70)

for date in DATES:
    # Informative header for each date
    print(f"\n{'='*70}")
    print(f"Processing: {date}")
    print(f"{'='*70}")

    # -------------------------
    # Load the fine-resolution SM file
    # -------------------------
    # Prefer the "relaxed" variant (if available) since it may contain more
    # valid pixels or fewer rejection flags. Fall back to the original file
    # if the relaxed version is not present.
    sm_file_relaxed = DATA_DIR / f"SM_fine_{date}_TBV_tauomega_ATBD_reg_relaxed.npz"
    sm_file_orig = DATA_DIR / f"SM_fine_{date}_TBV_tauomega_ATBD_reg.npz"
    if sm_file_relaxed.exists():
        sm_file = sm_file_relaxed
    elif sm_file_orig.exists():
        sm_file = sm_file_orig
    else:
        print(f"[WARN] SM file not found: {sm_file_relaxed.name} or {sm_file_orig.name}")
        # Skip this date if no fine SM file is available
        continue

    data = np.load(sm_file)
    sm_fine_full = data['soil_moisture']

    # Crop the fine grid to avoid edge artifacts and for consistent comparison
    sm_fine = sm_fine_full[:CROP_Y, :CROP_X]

    data = np.load(sm_file)
    sm_fine_full = data['soil_moisture']

    # Crop to remove edges
    sm_fine = sm_fine_full[:CROP_Y, :CROP_X]

    # -------------------------
    # Load or construct a coarse-resolution SM field
    # -------------------------
    # Preferred path: a pre-extracted SMAP NPZ file with keys 'sm_coarse',
    # optionally 'latitude' and 'longitude' to window the region. If this
    # exists and is reprojected to the native grid, use it directly. If not,
    # attempt to extract the spatial window corresponding to our study area
    # using lat/lon arrays. If coordinates are missing or shapes are tiny
    # (e.g., 3x3 grid for the whole domain), we expand by tiling as a simple
    # nearest-neighbor-like approach. If anything goes wrong, fall back to
    # aggregating the fine-resolution SM to a coarse (3x5) grid.
    sm_coarse_file = DATA_DIR / f"smap_sm_coarse_{date}.npz"
    if sm_coarse_file.exists():
        d = np.load(sm_coarse_file)
        # expected key: 'sm_coarse' (maybe reprojected to native grid)
        sm_coarse_full = d['sm_coarse']

        # Case A: coarse file already in native grid alignment -> crop
        if sm_coarse_full.shape == sm_fine_full.shape:
            sm_coarse = sm_coarse_full[:CROP_Y, :CROP_X]
            # Ensure we always compare the same native window
            sm_fine = sm_fine_full[:CROP_Y, :CROP_X]
        else:
            # Case B: shapes differ. Attempt a spatial window using lat/lon if provided
            try:
                lat = d.get('latitude')
                lon = d.get('longitude')
                if lat is not None and lon is not None:
                    # Build a boolean mask for the requested lon/lat box. The
                    # mask logic assumes lat/lon arrays align with sm_coarse_full
                    mask = ((lat >= LAT_MIN) & (lat <= LAT_MAX) & (lon >= LON_MIN) & (lon <= LON_MAX))
                    # If the mask matches the shape of sm_coarse_full and selects
                    # some pixels, extract the bounding subarray
                    if mask.shape == sm_coarse_full.shape and np.any(mask):
                        rows, cols = np.where(mask)
                        r0, r1 = rows.min(), rows.max() + 1
                        c0, c1 = cols.min(), cols.max() + 1
                        sm_coarse = sm_coarse_full[r0:r1, c0:c1]
                        # Crop/pad to our display window if needed
                        sm_coarse = sm_coarse[:CROP_Y, :CROP_X]
                    else:
                        # Fallback: small coarse grid -> tile to cover crop size
                        small = sm_coarse_full
                        reps_y = max(1, CROP_Y // small.shape[0])
                        reps_x = max(1, CROP_X // small.shape[1])
                        tiled = np.tile(small, (reps_y + 1, reps_x + 1))
                        sm_coarse = tiled[:CROP_Y, :CROP_X]
                else:
                    # No lat/lon info available: tile the small coarse grid
                    small = sm_coarse_full
                    reps_y = max(1, CROP_Y // small.shape[0])
                    reps_x = max(1, CROP_X // small.shape[1])
                    tiled = np.tile(small, (reps_y + 1, reps_x + 1))
                    sm_coarse = tiled[:CROP_Y, :CROP_X]
            except Exception:
                # Any unexpected error: warn and fallback to aggregated fine
                print(f"[WARN] Problem processing SMAP coarse for {date}, falling back to aggregated fine")
                sm_coarse = aggregate_to_coarse(sm_fine_full, native_shape=sm_fine_full.shape, coarse_shape=(3, 5))
    else:
        # No external coarse product: build a coarse-like field from fine data
        print(f"[WARN] SMAP coarse NPZ not found for {date}, falling back to aggregated fine")
        sm_coarse = aggregate_to_coarse(sm_fine_full, native_shape=sm_fine_full.shape, coarse_shape=(3, 5))
    
    # Build 36km aggregated coarse grid from available data
    try:
        # If we loaded a reprojected coarse on native grid use it for aggregation
        if 'sm_coarse_full' in locals():
            sm_coarse_agg = aggregate_to_coarse(sm_coarse_full, native_shape=sm_coarse_full.shape, coarse_shape=(3, 5))
        else:
            sm_coarse_agg = aggregate_to_coarse(sm_fine_full, native_shape=sm_fine_full.shape, coarse_shape=(3, 5))
    except Exception:
        sm_coarse_agg = aggregate_to_coarse(sm_fine_full, native_shape=sm_fine_full.shape, coarse_shape=(3, 5))

    # -------------------------
    # Compute simple summary statistics for reporting
    # -------------------------
    # Use physically plausible fine-pixel selection: 0 < SM < 1 and finite
    sm_fine_valid = sm_fine[(sm_fine > 0) & (sm_fine < 1) & np.isfinite(sm_fine)]
    sm_coarse_valid = sm_coarse_agg[np.isfinite(sm_coarse_agg)]

    # Print summary statistics for logging and quick inspection
    print(f"\nSM_fine (native ~3km):")
    print(f"  Shape: {sm_fine.shape}")
    print(f"  Mean: {np.nanmean(sm_fine_valid):.4f} m3/m3")
    print(f"  Std: {np.nanstd(sm_fine_valid):.4f} m3/m3")
    print(f"  Min: {np.nanmin(sm_fine_valid):.4f} m3/m3")
    print(f"  Max: {np.nanmax(sm_fine_valid):.4f} m3/m3")

    print(f"\nSM_coarse (aggregated ~36km):")
    print(f"  Shape: {sm_coarse_agg.shape}")
    print(f"  Mean: {np.nanmean(sm_coarse_valid):.4f} m3/m3")
    print(f"  Std: {np.nanstd(sm_coarse_valid):.4f} m3/m3")
    print(f"  Min: {np.nanmin(sm_coarse_valid):.4f} m3/m3")
    print(f"  Max: {np.nanmax(sm_coarse_valid):.4f} m3/m3")

    # -------------------------
    # Create comparison plot: three panels
    #  1) Native fine grid (cropped)
    #  2) Aggregated coarse grid (blocky view)
    #  3) Scatter plot comparing aggregated fine vs coarse pixels
    # -------------------------
    fig, axes = plt.subplots(1, 3, figsize=(18, 5))
    fig.suptitle(f'Soil Moisture Comparison - {date}', fontsize=16, fontweight='bold')

    # Panel 1: Fine-resolution map (shows spatial structure)
    ax = axes[0]
    im1 = ax.imshow(sm_fine, cmap='YlGnBu', vmin=0, vmax=0.5, extent=[LON_MIN, LON_MAX, LAT_MIN, LAT_MAX], origin='upper')
    ax.set_title(f'SM Fine (~3km)\n{sm_fine.shape[0]}x{sm_fine.shape[1]} pixels', 
                 fontsize=12, fontweight='bold')
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    cbar1 = plt.colorbar(im1, ax=ax, label='SM (m3/m3)')

    stats_text = f'Mean: {np.nanmean(sm_fine_valid):.3f}\n'
    stats_text += f'Std: {np.nanstd(sm_fine_valid):.3f}\n'
    stats_text += f'Range: [{np.nanmin(sm_fine_valid):.3f}, {np.nanmax(sm_fine_valid):.3f}]'
    ax.text(0.02, 0.98, stats_text, transform=ax.transAxes,
            fontsize=9, verticalalignment='top',
            bbox=dict(boxstyle='round', facecolor='white', alpha=0.85))

    # Panel 2: Coarse-resolution (visualized as blocky map). Use 'nearest'
    # interpolation to emphasize the coarse cell boundaries when shapes are small.
    ax = axes[1]
    im2 = ax.imshow(sm_coarse_agg, cmap='YlGnBu', vmin=0, vmax=0.5, extent=[LON_MIN, LON_MAX, LAT_MIN, LAT_MAX], origin='upper', interpolation='nearest')
    ax.set_title(f'SM Coarse (~36km)\n{sm_coarse_agg.shape[0]}x{sm_coarse_agg.shape[1]} pixels', 
                 fontsize=12, fontweight='bold')
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    cbar2 = plt.colorbar(im2, ax=ax, label='SM (m3/m3)')

    stats_text = f'Mean: {np.nanmean(sm_coarse_valid):.3f}\n'
    stats_text += f'Std: {np.nanstd(sm_coarse_valid):.3f}\n'
    stats_text += f'Range: [{np.nanmin(sm_coarse_valid):.3f}, {np.nanmax(sm_coarse_valid):.3f}]'
    ax.text(0.02, 0.98, stats_text, transform=ax.transAxes,
            fontsize=9, verticalalignment='top',
            bbox=dict(boxstyle='round', facecolor='white', alpha=0.85))

    # Panel 3: Scatter plot comparing coarse vs aggregated fine values.
    # We aggregate the fine grid to the same coarse shape so the scatter is
    # pixel-wise comparable.
    sm_fine_agg = aggregate_to_coarse(sm_fine_full[:CROP_Y, :CROP_X], native_shape=(CROP_Y, CROP_X), coarse_shape=sm_coarse_agg.shape)

    ax = axes[2]
    mask = np.isfinite(sm_fine_agg.ravel()) & np.isfinite(sm_coarse_agg.ravel())
    ax.scatter(sm_coarse_agg.ravel()[mask], sm_fine_agg.ravel()[mask], 
               alpha=0.6, s=100, edgecolors='black', linewidths=1)

    # Add 1:1 line to help visualize bias
    min_val = min(np.nanmin(sm_coarse_agg), np.nanmin(sm_fine_agg))
    max_val = max(np.nanmax(sm_coarse_agg), np.nanmax(sm_fine_agg))
    ax.plot([min_val, max_val], [min_val, max_val], 'r--', linewidth=2)

    ax.set_xlabel('SM Coarse (aggregated) [m3/m3]', fontsize=11)
    ax.set_ylabel('SM Fine (aggregated to coarse) [m3/m3]', fontsize=11)
    ax.set_title('Pixel-wise Comparison', fontsize=12, fontweight='bold')
    ax.grid(True, alpha=0.3)
    ax.legend()
    ax.set_aspect('equal')

    # Compute evaluation metrics (correlation, RMSE, bias) for valid pixels
    if mask.sum() > 0:
        corr = np.corrcoef(sm_coarse_agg.ravel()[mask], sm_fine_agg.ravel()[mask])[0, 1]
        rmse = np.sqrt(np.mean((sm_coarse_agg.ravel()[mask] - sm_fine_agg.ravel()[mask])**2))
        bias = np.mean(sm_fine_agg.ravel()[mask] - sm_coarse_agg.ravel()[mask])

        stats_text = f'Correlation: {corr:.3f}\n'
        stats_text += f'RMSE: {rmse:.4f}\n'
        stats_text += f'Bias: {bias:.4f}\n'
        stats_text += f'N pixels: {mask.sum()}'
        ax.text(0.02, 0.98, stats_text, transform=ax.transAxes,
                fontsize=9, verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='white', alpha=0.85))

    plt.tight_layout()

    # Save figure to disk
    output_path = OUTPUT_DIR / f"SM_fine_vs_coarse_{date}.png"
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    plt.close()

    print(f"\n  Plot saved: {output_path.name}")

print(f"\n{'='*70}")
print("ALL COMPARISONS COMPLETED")
print(f"{'='*70}")
